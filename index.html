  <script>
    /* ===== 設定 ===== */
    // API / データ取得設定
    const API_URL = 'https://script.google.com/macros/s/AKfycbxf6Ifxokz6W9w6E1KOwQxapCgpZAR1WE1VPn9MDnMIXLfRuLAqZwx9HyVzMyuC6nITJA/exec';
    const SHEET_KEY = 'perf';
    const INITIAL_FETCH = 200;     // 起動時の取得件数
    const HARD_LIMIT = 20000;      // 取得上限

    // 再試行・タイムアウト設定（最大500曲程度を想定し、平均応答~0.7sに3〜5倍のバッファを付与）
    const JSONP_TIMEOUT_MS = 3800; // JSONP 待機上限
    const SHORT_TRY_MS = 1400;     // 短期再試行
    const MAX_RETRY = 3;           // 再試行回数
    const IFRAME_WATCHDOG_MS = 10000; // iframe 代替の監視時間

    const MOBILE_MEDIA_QUERY = '(max-width: 768px)';
    const mediaQuery = window.matchMedia(MOBILE_MEDIA_QUERY);

    const debugLog = [];
    const DEBUG_LOG_LIMIT = 100;

    const state = {
      rows: [],           // [artist, title, cText, dText, cUrl, dUrl] + precomputed props
      total: 0, fetchedLimit: 0, debounce: null,
      lastReqId: 0, usedIframe: false,
      pendingHandler: null,
      globalTimer: null, shortTimer: null,
      iframeTimer: null, iframeReqId: null,
      lastFetchLimit: INITIAL_FETCH,
      sort: { key: 'none', dir: 'desc' }, // key: none|date|artist|title, dir: asc|desc
      isMobile: mediaQuery.matches,
      renderRaf: null,
    };

    /* ========= 共通 ========= */
    function $(id){ return document.getElementById(id); }
    function setTextIfChanged(el, text){ if (!el) return; if (el.textContent === text) return; el.textContent = text; }
    function setAriaIfChanged(el, name, value){ if (!el) return; if (el.getAttribute(name) === value) return; el.setAttribute(name, value); }
    function setStatus(text, opts={}){ const el=$('status'); if(!el) return; setTextIfChanged(el, text); if (opts.fallback) el.dataset.fallback='1'; else delete el.dataset.fallback; }
    function clearFallbackFlag(){ const el=$('status'); if(el) delete el.dataset.fallback; }

    // JSONP コールバック（Apps Script 側が onGviz(...) を叩く）
    window.onGviz = function(payload){
      clearFallbackFlag();
      if (typeof state.pendingHandler === 'function') state.pendingHandler(payload);
    };

    function logEvent(label, detail){
      try{
        const ts = new Date();
        const line = `[${ts.toISOString()}] ${label}` + (detail ? ` ${typeof detail === 'string' ? detail : JSON.stringify(detail)}` : '');
        debugLog.unshift(line);
        if (debugLog.length > DEBUG_LOG_LIMIT) debugLog.pop();
        const el = $('debug-log');
        if (el) el.textContent = debugLog.join('\n');
        console.log('[debug]', label, detail || '');
      }catch(e){
        console.warn('logEvent failed', e);
      }
    }

    function normalize(s){ return (s||'').toString().toLowerCase().replace(/\s+/g,' ').trim(); }
    function scheduleSearch(){ clearTimeout(state.debounce); state.debounce = setTimeout(requestRender, 160); }
    function showToast(msg){ const t=$('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1400); }

    function clearError(){
      const box = $('error-box'); if (!box) return;
      box.style.display = 'none';
      const msg = box.querySelector('.msg'); const actions = box.querySelector('.actions');
      if (msg) msg.innerHTML = '';
      if (actions) actions.innerHTML = '';
    }
    function showError(message, {detail='', retry=false}={}){
      const box = $('error-box'); if (!box) return;
      const msg = box.querySelector('.msg');
      const actions = box.querySelector('.actions');
      if (!msg || !actions) return;

      msg.innerHTML = '';
      const title = document.createElement('strong');
      title.textContent = '通信エラー';
      const body = document.createElement('div');
      body.textContent = message;
      msg.appendChild(title); msg.appendChild(body);

      if (detail) {
        const small = document.createElement('div');
        small.className = 'muted';
        small.textContent = detail;
        msg.appendChild(small);
      }

      actions.innerHTML = '';
      if (retry) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'btn';
        btn.textContent = '再試行';
        btn.addEventListener('click', ()=> fetchRows(state.lastFetchLimit || INITIAL_FETCH));
        actions.appendChild(btn);
      }

      box.style.display = 'flex';
    }

    async function copyText(text, {success='コピーしました', failure='コピーに失敗しました'}={}){
      const value = (text || '').toString().trim();
      if (!value) { showToast('コピー対象がありません'); return; }
      try{
        if(navigator.clipboard?.writeText) await navigator.clipboard.writeText(value);
        else {
          const ta=document.createElement('textarea'); ta.value=value; ta.setAttribute('readonly',''); ta.style.position='absolute'; ta.style.left='-9999px';
          document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove();
        }
        showToast(`${success}：${value}`);
      }catch(e){
        console.warn('copy failed', e);
        showToast(`${failure}。手動で選択してコピーしてください。`);
      }
    }
    function copyPair(title, artist){ return copyText(`${(title||'').trim()} / ${(artist||'').trim()}`, {success:'コピーしました', failure:'コピーに失敗しました'}); }

    // 弾幕コピー
    $('dm-copy').addEventListener('click', ()=>{
      copyText($('dm-select').value || '', {success:'弾幕をコピーしました', failure:'弾幕のコピーに失敗しました'});
    });

    function urlFromText(s){ if(!s) return ''; const m=String(s).match(/https?:\/\/\S+/); return m? m[0].replace(/[)\]\s]+$/, '') : ''; }
    function formatYmdLabel(s){ const m=/(\d{4})(\d{2})(\d{2})/.exec(String(s||'')); return m? `${m[1]}/${m[2]}/${m[3]}` : null; }
    function safeHttpUrl(u){ if(!u) return ''; try{ const url=new URL(String(u)); return (url.protocol==='http:'||url.protocol==='https:') ? url.href : ''; }catch{ return ''; } }

    function createLinkPill(href, label, title){
      if (!href) return null;
      const a=document.createElement('a');
      a.href=href; a.target='_blank'; a.rel='noopener noreferrer';
      a.className='btn-pill';
      a.title=title || label || 'リンク';
      a.textContent=label || 'リンク';
      return a;
    }
    function createCopyButton(title, artist){
      const btn=document.createElement('button'); btn.className='btn'; btn.textContent='コピー';
      const label = `${(title||'').trim()} / ${(artist||'').trim()}`.trim();
      btn.title = label ? `${label} をコピー` : '曲名 / アーティスト名をコピー';
      btn.setAttribute('aria-label', btn.title);
      btn.addEventListener('click',()=>copyPair(title,artist));
      return btn;
    }

    function showSkeleton(){
      const wrap=$('table'); if (!wrap) return;
      const frag=document.createDocumentFragment();
      for(let i=0;i<6;i++){
        const sk=document.createElement('div'); sk.className='skeleton';
        frag.appendChild(sk);
      }
      wrap.replaceChildren(frag);
      wrap.style.display = 'block';
      const listWrap = $('mblist');
      if (listWrap) listWrap.style.display = 'none';
    }
    function clearSkeleton(){
      const wrap=$('table');
      if (wrap) { wrap.replaceChildren(); wrap.style.display = 'none'; }
      const listWrap = $('mblist');
      if (listWrap) listWrap.style.display = 'none';
    }

    function getKindValue(){ const el = $('kind'); return el ? el.value : 'all'; }

    /* ===== ソート関連 ===== */
    function parseYmdInt(s){
      const m = /^(\d{4})(\d{2})(\d{2})$/.exec(String(s||'').trim());
      if (!m) return NaN;
      return Number(`${m[1]}${m[2]}${m[3]}`);
    }
    function compareStrings(a,b,{preNormalized=false}={}){
      const A = preNormalized ? (a||'') : normalize(a);
      const B = preNormalized ? (b||'') : normalize(b);
      if (A < B) return -1;
      if (A > B) return 1;
      return 0;
    }
    function applySort(rows, sort){
      if (!rows || !rows.length) return rows;
      if (!sort || sort.key === 'none') return rows;

      const dir = sort.dir === 'asc' ? 1 : -1;
      const arr = rows.slice();

      if (sort.key === 'date'){
        arr.sort((r1, r2)=>{
          const d1 = Number.isFinite(r1.dateInt) ? r1.dateInt : NaN;
          const d2 = Number.isFinite(r2.dateInt) ? r2.dateInt : NaN;
          const n1 = Number.isNaN(d1), n2 = Number.isNaN(d2);
          if (n1 && n2) return 0;
          if (n1) return 1;
          if (n2) return -1;
          return (d1 - d2) * dir;
        });
      } else if (sort.key === 'artist'){
        arr.sort((r1, r2)=> compareStrings(r1.artistLower, r2.artistLower, {preNormalized:true}) * dir);
      } else if (sort.key === 'title'){
        arr.sort((r1, r2)=> compareStrings(r1.titleLower, r2.titleLower, {preNormalized:true}) * dir);
      }
      return arr;
    }

    /* ===== 描画 ===== */
    function buildFilteredSongs(state){
      const q = normalize($('q').value || '');
      const rawLimit = $('limit').value;
      const kind = getKindValue();

      const limit = rawLimit === 'all'
        ? Math.min(HARD_LIMIT, state.total || state.rows.length)
        : Math.min(parseInt(rawLimit,10)||20, HARD_LIMIT);
      const limitLabel = rawLimit === 'all' ? '全件' : `${limit}件`;

      let filtered = state.rows;

      // 検索文字列（曲名・アーティスト）
      if (q) {
        filtered = filtered.filter(row => {
          const a = row.artistLower;
          const t = row.titleLower;
          return a.includes(q) || t.includes(q);
        });
      }

      // 対象フィルタ（cText 完全一致）
      if (kind !== 'all') {
        filtered = filtered.filter(([, , cText]) => String(cText || '').trim() === kind);
      }

      // ソート適用
      filtered = applySort(filtered, state.sort);

      return {
        rows: filtered.slice(0, limit),
        filteredCount: filtered.length,
        limit,
        limitLabel,
        kind,
        query: q,
      };
    }

    function buildStatusText(viewModel){
      const { rows, filteredCount, limitLabel, kind, query } = viewModel;
      const kindPart = (kind !== 'all') ? ` / ${kind}` : '';
      const sortPart = (state.sort.key === 'none')
        ? ''
        : ` / ソート: ${state.sort.key === 'date' ? '日付' : state.sort.key === 'artist' ? 'アーティスト' : '曲名'} ${state.sort.dir === 'asc' ? '昇順' : '降順'}`;

      if (query || kind !== 'all' || state.sort.key !== 'none') {
        return `${rows.length}件ヒット（全${filteredCount}件／総${state.total}件${kindPart}${sortPart}）／表示上限 ${limitLabel}`;
      }
      return `表示中 ${rows.length}件（総${state.total}件）／表示上限 ${limitLabel}`;
    }

    function renderTable(rows){
      const tableWrap = $('table');
      const table = document.createElement('table');
      table.className = 'stacked';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      const th = document.createElement('th');
      th.textContent = 'アーティスト／楽曲情報';
      trh.appendChild(th); thead.appendChild(trh); table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const fragRows = document.createDocumentFragment();

      rows.forEach(([artist, title, cText, dText, cUrl, dUrl])=>{
        const note = String(cText || '').trim();
        const cHref = safeHttpUrl(cUrl);
        const dHref = safeHttpUrl(dUrl) || safeHttpUrl(urlFromText(dText));
        const dLabel = formatYmdLabel(dText);

        /* 1行目：楽曲情報 */
        const trTop = document.createElement('tr'); trTop.className='item-top';
        const tdTop = document.createElement('td'); tdTop.style.borderBottom = 'none';
        const l1 = document.createElement('div'); l1.className='l1';
        const a1 = document.createElement('span'); a1.className='artist'; a1.textContent=artist||'';
        const sep = document.createElement('span'); sep.className='sep'; sep.textContent='/';
        const t1 = document.createElement('span'); t1.className='title'; t1.textContent=title||'';
        l1.appendChild(a1); l1.appendChild(sep); l1.appendChild(t1);
        tdTop.appendChild(l1);

        if (note) {
          const noteEl = document.createElement('div');
          noteEl.className = 'muted';
          noteEl.textContent = note;
          tdTop.appendChild(noteEl);
        }

        trTop.appendChild(tdTop);
        fragRows.appendChild(trTop);

        /* 2行目：操作 */
        const trOps = document.createElement('tr'); trOps.className='item-ops';
        const tdOps = document.createElement('td'); tdOps.style.borderTop = 'none';
        const ops = document.createElement('div'); ops.className='ops';

        const aC = createLinkPill(cHref, '▶歌枠', '歌枠直リンク');
        if (aC) ops.appendChild(aC);

        const aD = createLinkPill(dHref,
          dLabel ? `出典 ${dLabel}` : '出典元',
          dLabel ? `出典元 ${dLabel}` : '出典元情報'
        );
        if (aD) ops.appendChild(aD);

        ops.appendChild(createCopyButton(title, artist));

        tdOps.appendChild(ops); trOps.appendChild(tdOps); fragRows.appendChild(trOps);
      });

      tbody.appendChild(fragRows);
      table.appendChild(tbody);
      tableWrap.replaceChildren(table);
      tableWrap.style.display = 'block';
      $('mblist').style.display = 'none';
    }

    function renderMobile(rows){
      const listWrap  = $('mblist');
      listWrap.replaceChildren();

      const frag = document.createDocumentFragment();
      rows.forEach(([artist, title, cText, dText, cUrl, dUrl])=>{
        const note = String(cText || '').trim();
        const cHref = safeHttpUrl(cUrl);
        const dHref = safeHttpUrl(dUrl) || safeHttpUrl(urlFromText(dText));
        const dLabel = formatYmdLabel(dText);

        const item=document.createElement('div'); item.className='item';

        const l1=document.createElement('div'); l1.className='l1';
        const a1=document.createElement('span'); a1.className='artist'; a1.textContent=artist||'';
        const sep=document.createElement('span'); sep.className='sep'; sep.textContent='/';
        const t1=document.createElement('span'); t1.className='title'; t1.textContent=title||'';
        l1.appendChild(a1); l1.appendChild(sep); l1.appendChild(t1);

        const l2=document.createElement('div'); l2.className='l2';

        const aC = createLinkPill(cHref, '▶歌枠', '歌枠直リンク');
        if (aC) l2.appendChild(aC);

        const aD = createLinkPill(dHref,
          dLabel ? `出典 ${dLabel}` : '出典元',
          dLabel ? `出典元 ${dLabel}` : '出典元情報'
        );
        if (aD) l2.appendChild(aD);

        l2.appendChild(createCopyButton(title, artist));

        item.appendChild(l1); item.appendChild(l2);

        if (note) {
          const noteEl = document.createElement('div');
          noteEl.className = 'muted';
          noteEl.textContent = note;
          item.appendChild(noteEl);
        }
        frag.appendChild(item);
      });

      listWrap.replaceChildren(frag);
      listWrap.style.display='block';
    }

    function render(){
      clearFallbackFlag();

      const tableWrap = $('table');
      const listWrap  = $('mblist');
      const hint = $('hint');

      tableWrap.style.display = 'none';
      listWrap.style.display  = 'none';

      const view = buildFilteredSongs(state);

      setStatus(buildStatusText(view));

      if (view.rows.length === 0) {
        setTextIfChanged(hint, (view.query || view.kind !== 'all') ? '該当するデータがありません。' : '検索結果がここに表示されます。');
        return;
      }
      setTextIfChanged(hint, '');

      if (!state.isMobile) {
        renderTable(view.rows);
      } else {
        renderMobile(view.rows);
      }
    }

    function requestRender(){
      if (state.renderRaf) return;
      state.renderRaf = requestAnimationFrame(()=>{
        state.renderRaf = null;
        render();
      });
    }

    /* ===== 通信処理 ===== */

    function jsonpOnce(url, onerror, reqId){
      const s=document.createElement('script');
      s.src=url;
      s.async=true;
      s.dataset.jsonp = String(reqId||'');
      s.onerror=()=>{ try{ s.remove(); }catch{}; onerror && onerror(); };
      document.head.appendChild(s);
    }
    function cleanupJsonpScripts(reqId){
      const sel = reqId ? `script[data-jsonp="${reqId}"]` : 'script[data-jsonp]';
      document.querySelectorAll(sel).forEach(el=>{ try{ el.remove(); }catch{} });
    }

    function fetchRows(limit, attempt=0){
      const reqId = ++state.lastReqId;
      state.lastFetchLimit = limit;
      clearError();

      logEvent('fetch start', {reqId, limit, attempt});

      clearTimeout(state.shortTimer); state.shortTimer = null;
      clearTimeout(state.globalTimer); state.globalTimer = null;
      if (state.iframeTimer) { clearTimeout(state.iframeTimer); state.iframeTimer = null; state.iframeReqId = null; }
      state.usedIframe = false;
      state.pendingHandler = null;
      cleanupJsonpScripts();
      const prev = document.getElementById('gviz-frame'); if (prev) prev.remove();

      const base = API_URL.replace(/\/macros\/u\/\d+\//,'/macros/');
      const url  = `${base}?callback=onGviz&sheet=${encodeURIComponent(SHEET_KEY)}&limit=${Math.min(limit,HARD_LIMIT)}&authuser=0&v=${Date.now()}`;

      setStatus(attempt===0 ? '読み込み中…' : `読み込み中…（${attempt}）`, {fallback:false});
      showSkeleton();

      let settled = false;

      const fail = (message, detail='')=>{
        if (settled || reqId !== state.lastReqId) return;
        settled = true;
        clearTimeout(state.shortTimer); state.shortTimer = null;
        clearTimeout(state.globalTimer); state.globalTimer = null;
        if (state.iframeReqId === reqId && state.iframeTimer) clearTimeout(state.iframeTimer);
        state.iframeTimer = null; state.iframeReqId = null; state.usedIframe = false;
        const frame = document.getElementById('gviz-frame'); if (frame) frame.remove();
        cleanupJsonpScripts(reqId);
        state.pendingHandler = null;
        setStatus(message, {fallback:false});
        clearSkeleton();
        logEvent('fetch failed', {reqId, attempt, message, detail, usedIframe: state.usedIframe});
        if (detail) console.warn('fetchRows failed', {reqId, attempt, message, detail});
        else console.warn('fetchRows failed', {reqId, attempt, message});
        showError(message, {retry:true, detail});
      };

      state.pendingHandler = (payload)=>{
        clearFallbackFlag();
        if (settled || reqId !== state.lastReqId) return;
        settled = true;

        clearTimeout(state.shortTimer); state.shortTimer = null;
        clearTimeout(state.globalTimer); state.globalTimer = null;

        try{
          if (payload && payload.ok === false) {
            const errMsg = String(payload.error || 'サーバーがエラーを返しました。');
            fail('データ取得に失敗しました', errMsg);
            return;
          }
          if (!payload || !Array.isArray(payload.rows)) {
            fail('データ取得に失敗しました（不正なレスポンス）', 'レスポンス形式を確認してください。');
            return;
          }
          const rows = (payload.rows||[])
            .map(r => {
              const artist = r.artist || '';
              const title  = r.title  || '';
              const cText  = r.cText  || '';
              const dText  = r.dText  || '';
              const cUrl   = r.cUrl   || '';
              const dUrl   = r.dUrl   || '';

              const row = [ artist, title, cText, dText, cUrl, dUrl ];
              row.artistLower = normalize(artist);
              row.titleLower  = normalize(title);
              row.dateInt     = parseYmdInt(dText);
              return row;
            })
            .filter(([a,b]) => ((a||'')+(b||'')).trim() !== '');

          state.rows = rows;
          state.total = Number((payload.total ?? null) != null ? payload.total : (payload.matched ?? rows.length));

          const f = document.getElementById('gviz-frame'); if (f) f.remove();
          state.usedIframe = false;
          if (state.iframeReqId === reqId && state.iframeTimer) { clearTimeout(state.iframeTimer); }
          state.iframeTimer = null; state.iframeReqId = null;

          cleanupJsonpScripts(reqId);
          state.fetchedLimit = Math.max(state.fetchedLimit || 0, state.rows.length);

          clearError();
          setStatus(`読み込み完了：${state.rows.length}件（全${state.total}件）`, {fallback:false});
          clearSkeleton();
          logEvent('fetch success', {reqId, rows: state.rows.length, total: state.total, usedIframe: state.usedIframe});
          render();
          state.pendingHandler = null;
        }catch(e){
          console.error(e);
          fail('読み込みに失敗しました', '一時的なエラーです。再試行してください。');
        }
      };

      state.shortTimer = setTimeout(()=>{
        if (!settled && attempt < MAX_RETRY) {
          console.warn('retrying fetchRows (jsonp delay)', {reqId, attemptNext: attempt+1});
          logEvent('retry fetch (short timer)', {reqId, attemptNext: attempt+1});
          fetchRows(limit, attempt+1);
        }
      }, SHORT_TRY_MS);

      state.globalTimer = setTimeout(()=>{
        if (!settled && reqId === state.lastReqId) tryIframeFallback(limit, reqId, 'jsonp-timeout', fail);
      }, JSONP_TIMEOUT_MS);

      jsonpOnce(url, ()=>{
        if (settled || reqId !== state.lastReqId) return;
        clearTimeout(state.shortTimer); state.shortTimer = null;
        clearTimeout(state.globalTimer); state.globalTimer = null;
        logEvent('jsonp script load error', {reqId, attempt});
        const started = tryIframeFallback(limit, reqId, 'jsonp-load-error', fail);
        if (!started) {
          fail('データ取得に失敗しました（スクリプト読み込みエラー）', 'ネットワークまたは公開設定をご確認ください。');
        }
      }, reqId);
    }

    function tryIframeFallback(limit, reqId, reason, onTimeout){
      if (reqId !== state.lastReqId) return false;
      if ((state.rows && state.rows.length) > 0) return false;
      if (state.usedIframe) return false;
      state.usedIframe = true;

      logEvent('iframe fallback start', {reqId, reason, limit});

      const reasonLabel = reason === 'jsonp-timeout'
        ? '応答待ち超過'
        : reason === 'jsonp-load-error'
          ? 'スクリプト読み込みエラー'
          : reason;
      setStatus(`別ルートで取得中…（${reasonLabel}）`, {fallback:true});

      const old = document.getElementById('gviz-frame'); if (old) old.remove();

      const base = API_URL.replace(/\/macros\/u\/\d+\//,'/macros/');
      const urlFrame = `${base}?frame=1&sheet=${encodeURIComponent(SHEET_KEY)}&limit=${Math.min(limit,HARD_LIMIT)}&authuser=0&v=${Date.now()}`;

      const f = document.createElement('iframe');
      f.id = 'gviz-frame';
      f.src = urlFrame;
      f.style.display = 'none';
      f.width = 0; f.height = 0; f.tabIndex = -1;
      document.body.appendChild(f);

      clearTimeout(state.iframeTimer);
      state.iframeReqId = reqId;
      state.iframeTimer = setTimeout(()=>{
        if (state.lastReqId !== reqId) return;
        if (!$('status')?.dataset?.fallback) return;
        if ((state.rows && state.rows.length) > 0) return;

        const detail = reason === 'jsonp-timeout'
          ? 'JSONP 応答がなくタイムアウトしました。公開設定やネットワークを確認してください。'
          : reason === 'jsonp-load-error'
            ? 'スクリプトが読み込めませんでした。公開設定やネットワーク状態をご確認ください。'
            : '別ルートの取得がタイムアウトしました。公開設定やネットワーク状態をご確認ください。';

        logEvent('iframe fallback timeout', {reqId, reason, detail});

        if (typeof onTimeout === 'function') {
          onTimeout('取得がタイムアウトしました。再試行してください。', detail);
        } else {
          setStatus('取得がタイムアウトしました（公開設定/デプロイ確認・ネットワーク再試行）', {fallback:false});
          const g = document.getElementById('gviz-frame'); if (g) g.remove();
          state.usedIframe = false;
          clearSkeleton();
          showError('取得がタイムアウトしました。再試行してください。', {retry:true, detail});
        }
      }, IFRAME_WATCHDOG_MS);

      return true;
    }

    // iframe 側からの onmessage
    window.addEventListener('message', (ev)=>{
      const d = ev?.data; if (!d || d.type !== 'gviz') return;
      clearFallbackFlag();
      logEvent('iframe message received', {hasPayload: !!d.payload, reqId: state.iframeReqId});
      if (typeof state.pendingHandler === 'function') state.pendingHandler(d.payload);
    });

    // オフライン/オンライン
    window.addEventListener('offline', ()=>{ setStatus('オフラインです。接続を確認してください。', {fallback:false}); }, {passive:true});
    window.addEventListener('online',  ()=>{ clearError(); setStatus('オンラインに復帰しました。再取得しています…', {fallback:false}); fetchRows(INITIAL_FETCH); }, {passive:true});

    document.addEventListener('visibilitychange', ()=>{
      if (document.visibilityState === 'visible') {
        if ($('status')?.dataset?.fallback && (state.rows && state.rows.length)>0) clearFallbackFlag();
      }
    }, {passive:true});

    // 初回ロード
    fetchRows(INITIAL_FETCH);

    /* ===== イベント ===== */
    $('q').addEventListener('input', scheduleSearch);
    $('limit').addEventListener('change', ()=>{
      const raw = $('limit').value;
      if (raw === 'all' && (state.fetchedLimit||0) < (state.total||HARD_LIMIT)) {
        setStatus('全件を取得しています…', {fallback:false});
        fetchRows(HARD_LIMIT);
      } else {
        render();
      }
    });
    (function(){ const el=$('kind'); if (el) el.addEventListener('change', render); })();
    (function(){ const el=$('refetch'); if (el) el.addEventListener('click', ()=>{
      setStatus('最新のデータを再取得しています…', {fallback:false});
      fetchRows(state.lastFetchLimit || INITIAL_FETCH);
    }); })();

    // 並び替えUI
    function updateSortButtons(){
      const btnLatest = $('sort-latest-toggle');
      const btnTitle = $('sort-title-toggle');
      const btnArtist = $('sort-artist-toggle');

      const applyButtonState = (btn, label, isActive, arrow)=>{
        if (!btn) return;
        setTextIfChanged(btn, `${label}${arrow}`);
        setAriaIfChanged(btn, 'aria-pressed', isActive ? 'true' : 'false');
        btn.classList.toggle('btn-ghost', !isActive);
      };

      const isLatest = state.sort.key === 'date';
      const latestArrow = isLatest ? (state.sort.dir === 'asc' ? '↑' : '↓') : '↓';
      applyButtonState(btnLatest, '最新曲順', isLatest, latestArrow);

      const isTitle = state.sort.key === 'title';
      const titleArrow = isTitle ? (state.sort.dir === 'asc' ? '↑' : '↓') : '↓';
      applyButtonState(btnTitle, '曲名順', isTitle, titleArrow);

      const isArtist = state.sort.key === 'artist';
      const artistArrow = isArtist ? (state.sort.dir === 'asc' ? '↑' : '↓') : '↓';
      applyButtonState(btnArtist, 'アーティスト名順', isArtist, artistArrow);
    }

    function setSort(key, dir){
      state.sort.key = key; state.sort.dir = dir;
      updateSortButtons();
      render();
    }

    $('sort-latest-toggle').addEventListener('click', ()=>{
      const nextDir = (state.sort.key === 'date' && state.sort.dir === 'desc') ? 'asc' : 'desc';
      setSort('date', nextDir);
    });
    $('sort-title-toggle').addEventListener('click', ()=>{
      const nextDir = (state.sort.key === 'title' && state.sort.dir === 'desc') ? 'asc' : 'desc';
      setSort('title', nextDir);
    });
    $('sort-artist-toggle').addEventListener('click', ()=>{
      const nextDir = (state.sort.key === 'artist' && state.sort.dir === 'desc') ? 'asc' : 'desc';
      setSort('artist', nextDir);
    });

    function handleMediaChange(ev){
      const next = ev?.matches ?? mediaQuery.matches;
      if (state.isMobile === next) return;
      state.isMobile = next;
      requestRender();
    }
    mediaQuery.addEventListener?.('change', handleMediaChange, {passive:true});
    window.addEventListener('resize', ()=>{ requestRender(); }, {passive:true});

    updateSortButtons();
    console.log('UI layout + sort v20251029');
  </script>
